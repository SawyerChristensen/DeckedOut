//
//  MessagesViewController.swift
//  DeckedOut MessagesExtension
//
//  Created by Sawyer Christensen on 6/19/25.
//

import UIKit
import Messages
import SwiftUI
import AVFoundation //for audio

class MessagesViewController: MSMessagesAppViewController {
    
    private var menuViewModel: MenuViewModel? //what keeps track of if the menu is compact/extended
    let gameManager = GameManager()//Le Game Engine
    
    // MARK: â€“ View Life-Cycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setupAudioSession()
        
        // Listen for turn completion
        gameManager.onTurnCompleted = { [weak self] gameState in
            self?.sendGameMove(gameState: gameState)
        }
    }
    
    private func setupAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setCategory(.ambient, mode: .default) //.ambient allows mixing with background music and respects silent switch
            try AVAudioSession.sharedInstance().setActive(true)
        } catch {
            print("Could not set up audio session: \(error)")
        }
        _ = SoundManager.instance //this *should* load the sound manager into ram and trigger the lazy init
    }

    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        super.willBecomeActive(with: conversation)
        if let selectedMessage = conversation.selectedMessage {
            decodeMessage(from: selectedMessage, conversation: conversation)
        }
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different conversation or quits Messages.
        gameManager.saveMidTurnState(conversationID: conversation.localParticipantIdentifier.uuidString)
        super.didResignActive(with: conversation)
    }
    
    override func didSelect(_ message: MSMessage, conversation: MSConversation) {
        // Called when a user selects a message when the app is already running (like in compact view) //can also handle this in willTransition??
        super.didSelect(message, conversation: conversation)
        decodeMessage(from: message, conversation: conversation)
        presentGameController()
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this extension on a remote device. Note: this also triggers when a message is sent. It always updates when a new message enters the conversation
        // Use this method to trigger UI updates in response to the message. ^^
        super.didReceive(message, conversation: conversation)
        decodeMessage(from: message, conversation: conversation)
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) { //maybe use this to bring up waiting for opponent overlays?
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) { //"need" to account for .transcript? didnt in hex chess...
        // Called before the extension transitions to a new presentation style.
        super.willTransition(to: presentationStyle)
        guard let conversation = activeConversation else { return }
    
        if gameManager.playerHand == [] && children.first is UIHostingController<MainMenuView> {
            withAnimation(.easeInOut(duration: 0.3)) {
                menuViewModel?.presentationStyle = presentationStyle }
            return
        }
        
        if presentationStyle == .expanded && gameManager.playerHand != [] {
            presentGameController() //there is a game loaded, and we're switching to game view
        } else { //there is either no game loaded, or we are switching to the compact view
            presentMenuController(for: presentationStyle, with: conversation)
        }
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }
    
    // MARK: - Helper functions
    
    private func presentMenuController(for presentationStyle: MSMessagesAppPresentationStyle, with conversation: MSConversation) {
        let viewModel = MenuViewModel(presentationStyle: presentationStyle)
        self.menuViewModel = viewModel
        
        let menuView = MainMenuView(viewModel: viewModel) { [weak self] selectedSize in
            self?.createGame(conversation: conversation, handSize: selectedSize)
        }
                
        presentView(UIHostingController(rootView: menuView))
        requestPresentationStyle(.compact)
    }
    
    private func presentGameController() {
        //removeAllChildViewControllers()
        let gameRootView = GinRootView(game: self.gameManager)
        let gameController = UIHostingController(rootView: gameRootView)
        
        presentView(gameController)
        requestPresentationStyle(.expanded)
    }
    
    private func presentView(_ viewController: UIViewController) {
        //dismiss any pop-up (like a win screen) that might be open
        dismiss(animated: false) { [weak self] in
            guard let self = self else { return }
            
            //remove all existing child view controllers
            for child in self.children {
                child.willMove(toParent: nil)
                child.view.removeFromSuperview()
                child.removeFromParent()
            }
            
            //add the new view controller
            self.addChild(viewController)
            viewController.view.frame = self.view.bounds
            viewController.view.translatesAutoresizingMaskIntoConstraints = false
            self.view.addSubview(viewController.view)
            
            NSLayoutConstraint.activate([
                viewController.view.topAnchor.constraint(equalTo: self.view.topAnchor),
                viewController.view.bottomAnchor.constraint(equalTo: self.view.bottomAnchor),
                viewController.view.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),
                viewController.view.trailingAnchor.constraint(equalTo: self.view.trailingAnchor)
            ])
            
            viewController.didMove(toParent: self)
        }
    }
    
    private func createGame(conversation: MSConversation, handSize: Int) { //this is general right now! modify per game selected
        let session = MSSession()
        let message = MSMessage(session: session)
        let layout = MSMessageTemplateLayout()
        
        layout.image = UIImage(named: "GinDefault")
        layout.caption = NSLocalizedString("Let's Play Gin!", comment: "1st iMessage layout caption")
        message.layout = layout
        message.summaryText = NSLocalizedString("Let's Play Gin!", comment: "1st iMessage summary text")
        
        let startingGameState = gameManager.createNewGameState(withHandSize: handSize)
        guard let jsonData = try? JSONEncoder().encode(startingGameState) else { return }
        let jsonString = jsonData.base64EncodedString()
        var components = URLComponents()
        components.queryItems = [URLQueryItem(name: "gameState", value: jsonString)]
        message.url = components.url
        
        conversation.insert(message) { error in
            if let error = error {
                print("Error inserting message: \(error.localizedDescription)")
            }
        }
        
    }
    
    func sendGameMove(gameState: GameState) {
        guard let conversation = activeConversation else { return }
        guard let jsonData = try? JSONEncoder().encode(gameState) else { return }
        
        // Package the game state further
        let jsonString = jsonData.base64EncodedString()
        var components = URLComponents()
        components.queryItems = [URLQueryItem(name: "gameState", value: jsonString)]
        
        // Create the message & attach data
        let message = MSMessage(session: conversation.selectedMessage?.session ?? MSSession())
        message.url = components.url
        
        // Message Appearance
        let layout = MSMessageTemplateLayout()
        if gameManager.playerHasWon {
            layout.image = UIImage(named: "GinGameWon")
            layout.caption = NSLocalizedString("I won in Gin!", comment: "")
        } else {
            layout.image = UIImage(named: "GinDefault")
            layout.caption = NSLocalizedString("Your turn in Gin!", comment: "iMessage layout caption")
            message.summaryText = NSLocalizedString("Gin", comment: "1st iMessage summary text") }
        message.layout = layout
        
        gameManager.clearMidTurnState(conversationID: conversation.localParticipantIdentifier.uuidString)
        
        // ...aaaand send!
        conversation.send(message) { error in
            if let error = error { print(error) }
        }
    }
    
    private func decodeMessage(from message: MSMessage, conversation: MSConversation) {
        guard let url = message.url,
              let components = URLComponents(url: url, resolvingAgainstBaseURL: false),
              let queryItems = components.queryItems,
              let stateItem = queryItems.first(where: { $0.name == "gameState" }),
              let stateString = stateItem.value,
              let stateData = Data(base64Encoded: stateString),
              let loadedState = try? JSONDecoder().decode(GameState.self, from: stateData)
        else {
            // If any step fails (e.g., this is a new conversation with no history),
            // we just return and let the default "New Game" state stand.
            print("Failed to decode the recieved message")
            return
        }
        
        let senderID = message.senderParticipantIdentifier
        let isFromMe = !conversation.remoteParticipantIdentifiers.contains(senderID)
        gameManager.loadState(loadedState, isPlayersTurn: !isFromMe, conversationID: conversation.localParticipantIdentifier.uuidString)
    }
}
